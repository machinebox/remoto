// Code generated by Remoto; DO NOT EDIT.

package example

import (
	"context"
	"encoding/json"
	"io"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"strconv"

	"github.com/oxtoacart/bpool"
	"github.com/pkg/errors"

	"github.com/machinebox/remoto/remototypes"
)

// GreetFormatterClient accesses remote GreetFormatter services.
type GreetFormatterClient struct {
	// endpoint is the HTTP endpoint of the remote server.
	endpoint string
	// httpclient is the http.Client to use to make requests.
	httpclient *http.Client
	// bufs is a buffer pool
	bufs *bpool.BufferPool
}

// NewGreetFormatterClient makes a new GreetFormatterClient that will
// use the specified http.Client to make requests.
func NewGreetFormatterClient(endpoint string, client *http.Client) *GreetFormatterClient {
	return &GreetFormatterClient{
		endpoint:   endpoint,
		httpclient: client,
		bufs:       bpool.NewBufferPool(48),
	}
}

//
func (c *GreetFormatterClient) Greet(ctx context.Context, request *GreetFormatRequest) (*GreetResponse, error) {
	resp, err := c.GreetMulti(ctx, []*GreetFormatRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("GreetFormatter.Greet: no response")
	}
	return resp[0], nil
}

func (c *GreetFormatterClient) GreetMulti(ctx context.Context, requests []*GreetFormatRequest) ([]*GreetResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "GreetFormatter.Greet: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))

	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "GreetFormatter.Greet: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/GreetFormatter.Greet", buf)
	if err != nil {
		return nil, errors.Wrap(err, "GreetFormatter.Greet: new request")
	}
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "GreetFormatter.Greet: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("GreetFormatter.Greet: remote service returned %d", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "GreetFormatter.Greet: read response body")
	}
	var resps []*GreetResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "GreetFormatter.Greet: decode response body")
	}
	return resps, nil
}

// GreeterClient accesses remote Greeter services.
type GreeterClient struct {
	// endpoint is the HTTP endpoint of the remote server.
	endpoint string
	// httpclient is the http.Client to use to make requests.
	httpclient *http.Client
	// bufs is a buffer pool
	bufs *bpool.BufferPool
}

// NewGreeterClient makes a new GreeterClient that will
// use the specified http.Client to make requests.
func NewGreeterClient(endpoint string, client *http.Client) *GreeterClient {
	return &GreeterClient{
		endpoint:   endpoint,
		httpclient: client,
		bufs:       bpool.NewBufferPool(48),
	}
}

//
func (c *GreeterClient) Greet(ctx context.Context, request *GreetRequest) (*GreetResponse, error) {
	resp, err := c.GreetMulti(ctx, []*GreetRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("Greeter.Greet: no response")
	}
	return resp[0], nil
}

func (c *GreeterClient) GreetMulti(ctx context.Context, requests []*GreetRequest) ([]*GreetResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "Greeter.Greet: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))

	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "Greeter.Greet: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Greeter.Greet", buf)
	if err != nil {
		return nil, errors.Wrap(err, "Greeter.Greet: new request")
	}
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "Greeter.Greet: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("Greeter.Greet: remote service returned %d", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "Greeter.Greet: read response body")
	}
	var resps []*GreetResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "Greeter.Greet: decode response body")
	}
	return resps, nil
}

//
func (c *GreeterClient) GreetPhoto(ctx context.Context, request *GreetPhotoRequest) (*GreetPhotoResponse, error) {
	resp, err := c.GreetPhotoMulti(ctx, []*GreetPhotoRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("Greeter.GreetPhoto: no response")
	}
	return resp[0], nil
}

func (c *GreeterClient) GreetPhotoMulti(ctx context.Context, requests []*GreetPhotoRequest) ([]*GreetPhotoResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "Greeter.GreetPhoto: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))

	var files int
	for i := range requests {
		if requests[i].filePhoto != nil {
			fieldName := "_files[" + strconv.Itoa(files) + "]"
			requests[i].Photo = remototypes.NewFile(fieldName)
			f, err := w.CreateFormFile(fieldName, "todo.dat")
			if err != nil {
				return nil, errors.Wrap(err, "Greeter.GreetPhoto: create form file")
			}
			if _, err := io.Copy(f, requests[i].filePhoto); err != nil {
				return nil, errors.Wrap(err, "Greeter.GreetPhoto: reading file")
			}
			files++
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}

	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "Greeter.GreetPhoto: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Greeter.GreetPhoto", buf)
	if err != nil {
		return nil, errors.Wrap(err, "Greeter.GreetPhoto: new request")
	}
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "Greeter.GreetPhoto: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("Greeter.GreetPhoto: remote service returned %d", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "Greeter.GreetPhoto: read response body")
	}
	var resps []*GreetPhotoResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "Greeter.GreetPhoto: decode response body")
	}
	return resps, nil
}

// GreetFormatRequest is the request for GreetFormatter.Greet.
type GreetFormatRequest struct {
	//
	Format string

	//
	Name string
}

// GreetResponse is the response for Greeter.Greet and GreetFormatter.Greet.
type GreetResponse struct {
	//
	Greeting string

	// Error is an error message if one occurred.
	Error string
}

// GreetRequest is the request for Greeter.Greet.
type GreetRequest struct {
	//
	Name string
}

//
type GreetPhotoRequest struct {
	//
	Photo remototypes.File

	filePhoto     io.Reader
	filenamePhoto string

	//
	Name string
}

// SetPhoto sets the file for Photo.
func (s *GreetPhotoRequest) SetPhoto(r io.Reader, filename string) {
	s.filePhoto = r
	s.filenamePhoto = filename
}

//
type GreetPhotoResponse struct {
	//
	Greeting string

	// Error is an error message if one occurred.
	Error string
}
