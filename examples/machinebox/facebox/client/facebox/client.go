// Code generated by Remoto; DO NOT EDIT.

package machinebox

import (
	"context"
	"encoding/json"
	"io"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"strconv"

	"github.com/machinebox/remoto/remototypes"
	"github.com/oxtoacart/bpool"
	"github.com/pkg/errors"
)

// FaceboxClient accesses remote Facebox services.
type FaceboxClient struct {
	// endpoint is the HTTP endpoint of the remote server.
	endpoint string
	// httpclient is the http.Client to use to make requests.
	httpclient *http.Client
	// bufs is a buffer pool
	bufs *bpool.BufferPool
}

// NewFaceboxClient makes a new FaceboxClient that will
// use the specified http.Client to make requests.
func NewFaceboxClient(endpoint string, client *http.Client) *FaceboxClient {
	return &FaceboxClient{
		endpoint:   endpoint,
		httpclient: client,
		bufs:       bpool.NewBufferPool(48),
	}
}

// CheckFaceprint checks to see if a Faceprint matches any known
// faces.
func (c *FaceboxClient) CheckFaceprint(ctx context.Context, request *CheckFaceprintRequest) (*CheckFaceprintResponse, error) {
	resp, err := c.CheckFaceprintMulti(ctx, []*CheckFaceprintRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.CheckFaceprint: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) CheckFaceprintMulti(ctx context.Context, requests []*CheckFaceprintRequest) ([]*CheckFaceprintResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFaceprint: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.CheckFaceprint: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.CheckFaceprint: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFaceprint: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.CheckFaceprint", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFaceprint: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFaceprint: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.CheckFaceprint: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFaceprint: read response body")
	}
	var resps []*CheckFaceprintResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFaceprint: decode response body")
	}
	return resps, nil
}

// CheckFile checks an image file for faces.
func (c *FaceboxClient) CheckFile(ctx context.Context, request *CheckFileRequest) (*CheckFileResponse, error) {
	resp, err := c.CheckFileMulti(ctx, []*CheckFileRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.CheckFile: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) CheckFileMulti(ctx context.Context, requests []*CheckFileRequest) ([]*CheckFileResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFile: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.CheckFile: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.CheckFile: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFile: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.CheckFile", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFile: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFile: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.CheckFile: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFile: read response body")
	}
	var resps []*CheckFileResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckFile: decode response body")
	}
	return resps, nil
}

// CheckURL checks a hosted image file for faces.
func (c *FaceboxClient) CheckURL(ctx context.Context, request *CheckURLRequest) (*CheckURLResponse, error) {
	resp, err := c.CheckURLMulti(ctx, []*CheckURLRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.CheckURL: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) CheckURLMulti(ctx context.Context, requests []*CheckURLRequest) ([]*CheckURLResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckURL: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.CheckURL: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.CheckURL: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckURL: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.CheckURL", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckURL: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckURL: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.CheckURL: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckURL: read response body")
	}
	var resps []*CheckURLResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.CheckURL: decode response body")
	}
	return resps, nil
}

// FaceprintCompare compares faceprints to a specified target describing
// similarity.
func (c *FaceboxClient) FaceprintCompare(ctx context.Context, request *FaceprintCompareRequest) (*FaceprintCompareResponse, error) {
	resp, err := c.FaceprintCompareMulti(ctx, []*FaceprintCompareRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.FaceprintCompare: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) FaceprintCompareMulti(ctx context.Context, requests []*FaceprintCompareRequest) ([]*FaceprintCompareResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.FaceprintCompare: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.FaceprintCompare: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.FaceprintCompare: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.FaceprintCompare: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.FaceprintCompare", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.FaceprintCompare: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.FaceprintCompare: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.FaceprintCompare: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.FaceprintCompare: read response body")
	}
	var resps []*FaceprintCompareResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.FaceprintCompare: decode response body")
	}
	return resps, nil
}

// GetState gets the Facebox state file.
func (c *FaceboxClient) GetState(ctx context.Context, request *GetStateRequest) (io.ReadCloser, error) {
	b, err := json.Marshal([]interface{}{request})
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.GetState: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.GetState: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.GetState: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.GetState: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.GetState", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.GetState: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.GetState: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.GetState: remote service returned %s", resp.Status)
	}
	return resp.Body, nil
}

// PutState sets the Facebox state file.
func (c *FaceboxClient) PutState(ctx context.Context, request *PutStateRequest) (*PutStateResponse, error) {
	resp, err := c.PutStateMulti(ctx, []*PutStateRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.PutState: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) PutStateMulti(ctx context.Context, requests []*PutStateRequest) ([]*PutStateResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.PutState: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.PutState: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.PutState: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.PutState: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.PutState", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.PutState: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.PutState: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.PutState: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.PutState: read response body")
	}
	var resps []*PutStateResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.PutState: decode response body")
	}
	return resps, nil
}

// RemoveID removes a face with the specified ID.
func (c *FaceboxClient) RemoveID(ctx context.Context, request *RemoveIDRequest) (*RemoveIDResponse, error) {
	resp, err := c.RemoveIDMulti(ctx, []*RemoveIDRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.RemoveID: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) RemoveIDMulti(ctx context.Context, requests []*RemoveIDRequest) ([]*RemoveIDResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RemoveID: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.RemoveID: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.RemoveID: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RemoveID: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.RemoveID", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RemoveID: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RemoveID: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.RemoveID: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RemoveID: read response body")
	}
	var resps []*RemoveIDResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RemoveID: decode response body")
	}
	return resps, nil
}

// Rename changes a person&#39;s name.
func (c *FaceboxClient) Rename(ctx context.Context, request *RenameRequest) (*RenameResponse, error) {
	resp, err := c.RenameMulti(ctx, []*RenameRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.Rename: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) RenameMulti(ctx context.Context, requests []*RenameRequest) ([]*RenameResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.Rename: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.Rename: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.Rename: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.Rename: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.Rename", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.Rename: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.Rename: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.Rename: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.Rename: read response body")
	}
	var resps []*RenameResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.Rename: decode response body")
	}
	return resps, nil
}

// RenameID changes the name of a previously taught face, by ID.
func (c *FaceboxClient) RenameID(ctx context.Context, request *RenameIDRequest) (*RenameIDResponse, error) {
	resp, err := c.RenameIDMulti(ctx, []*RenameIDRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.RenameID: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) RenameIDMulti(ctx context.Context, requests []*RenameIDRequest) ([]*RenameIDResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RenameID: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.RenameID: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.RenameID: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RenameID: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.RenameID", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RenameID: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RenameID: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.RenameID: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RenameID: read response body")
	}
	var resps []*RenameIDResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.RenameID: decode response body")
	}
	return resps, nil
}

// SimilarFile checks for similar faces from the face in an image file.
func (c *FaceboxClient) SimilarFile(ctx context.Context, request *SimilarFileRequest) (*SimilarFileResponse, error) {
	resp, err := c.SimilarFileMulti(ctx, []*SimilarFileRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.SimilarFile: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) SimilarFileMulti(ctx context.Context, requests []*SimilarFileRequest) ([]*SimilarFileResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarFile: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.SimilarFile: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.SimilarFile: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarFile: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.SimilarFile", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarFile: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarFile: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.SimilarFile: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarFile: read response body")
	}
	var resps []*SimilarFileResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarFile: decode response body")
	}
	return resps, nil
}

// SimilarID checks for similar faces by ID.
func (c *FaceboxClient) SimilarID(ctx context.Context, request *SimilarIDRequest) (*SimilarIDResponse, error) {
	resp, err := c.SimilarIDMulti(ctx, []*SimilarIDRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.SimilarID: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) SimilarIDMulti(ctx context.Context, requests []*SimilarIDRequest) ([]*SimilarIDResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarID: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.SimilarID: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.SimilarID: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarID: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.SimilarID", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarID: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarID: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.SimilarID: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarID: read response body")
	}
	var resps []*SimilarIDResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarID: decode response body")
	}
	return resps, nil
}

// SimilarURL checks for similar faces in a hosted image file.
func (c *FaceboxClient) SimilarURL(ctx context.Context, request *SimilarURLRequest) (*SimilarURLResponse, error) {
	resp, err := c.SimilarURLMulti(ctx, []*SimilarURLRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.SimilarURL: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) SimilarURLMulti(ctx context.Context, requests []*SimilarURLRequest) ([]*SimilarURLResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarURL: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.SimilarURL: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.SimilarURL: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarURL: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.SimilarURL", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarURL: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarURL: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.SimilarURL: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarURL: read response body")
	}
	var resps []*SimilarURLResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.SimilarURL: decode response body")
	}
	return resps, nil
}

// TeachFaceprint teaches Facebox about a face from a Faceprint.
func (c *FaceboxClient) TeachFaceprint(ctx context.Context, request *TeachFaceprintRequest) (*TeachFaceprintResponse, error) {
	resp, err := c.TeachFaceprintMulti(ctx, []*TeachFaceprintRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.TeachFaceprint: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) TeachFaceprintMulti(ctx context.Context, requests []*TeachFaceprintRequest) ([]*TeachFaceprintResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFaceprint: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.TeachFaceprint: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.TeachFaceprint: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFaceprint: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.TeachFaceprint", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFaceprint: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFaceprint: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.TeachFaceprint: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFaceprint: read response body")
	}
	var resps []*TeachFaceprintResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFaceprint: decode response body")
	}
	return resps, nil
}

// TeachFile teaches Facebox a new face from an image file.
func (c *FaceboxClient) TeachFile(ctx context.Context, request *TeachFileRequest) (*TeachFileResponse, error) {
	resp, err := c.TeachFileMulti(ctx, []*TeachFileRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.TeachFile: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) TeachFileMulti(ctx context.Context, requests []*TeachFileRequest) ([]*TeachFileResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFile: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.TeachFile: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.TeachFile: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFile: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.TeachFile", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFile: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFile: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.TeachFile: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFile: read response body")
	}
	var resps []*TeachFileResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachFile: decode response body")
	}
	return resps, nil
}

// TeachURL teaches Facebox a new face from an image on the web.
func (c *FaceboxClient) TeachURL(ctx context.Context, request *TeachURLRequest) (*TeachURLResponse, error) {
	resp, err := c.TeachURLMulti(ctx, []*TeachURLRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("FaceboxClient.TeachURL: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) TeachURLMulti(ctx context.Context, requests []*TeachURLRequest) ([]*TeachURLResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachURL: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.TeachURL: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "FaceboxClient.TeachURL: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachURL: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.TeachURL", buf)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachURL: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachURL: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("FaceboxClient.TeachURL: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachURL: read response body")
	}
	var resps []*TeachURLResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "FaceboxClient.TeachURL: decode response body")
	}
	return resps, nil
}

// CheckFaceprintRequest is the request object for CheckFaceprint calls.
type CheckFaceprintRequest struct {

	// Faceprints is a list of Faceprints to check.
	Faceprints []string `json:"faceprints"`
}

// CheckFaceprintResponse is the response object for CheckFaceprint calls.
type CheckFaceprintResponse struct {

	// Faces is a list of faces checked from Faceprints.
	Faces []FaceprintFace `json:"faces"`
	// Error is an error message if one occurred.
	Error string `json:"error"`
}

// CheckFileRequest is the request object for CheckFile calls.
type CheckFileRequest struct {

	// File is the image to check for faces.
	File remototypes.File `json:"file"`
}

// SetFile sets the file for the File field.
func (s *CheckFileRequest) SetFile(ctx context.Context, filename string, r io.Reader) context.Context {
	files, ok := ctx.Value(contextKeyFiles).(map[string]file)
	if !ok {
		files = make(map[string]file)
	}
	fieldname := "files[" + strconv.Itoa(len(files)) + "]"
	files[fieldname] = file{r: r, filename: filename}
	ctx = context.WithValue(ctx, contextKeyFiles, files)
	s.File = remototypes.File{
		Fieldname: fieldname,
		Filename:  filename,
	}
	return ctx
}

// CheckFileResponse is the response object for CheckFile calls.
type CheckFileResponse struct {

	// Faces is a list of faces that were found.
	Faces []Face `json:"faces"`
	// Error is an error message if one occurred.
	Error string `json:"error"`
}

// CheckURLRequest is the request object for CheckURL calls.
type CheckURLRequest struct {

	// URL is the address of the image to check.
	URL string `json:"url"`
}

// CheckURLResponse is the response object for CheckURL calls.
type CheckURLResponse struct {

	// Faces is a list of faces that were found.
	Faces []Face `json:"faces"`
	// Error is an error message if one occurred.
	Error string `json:"error"`
}

// Face describes a face.
type Face struct {

	// ID is the identifier of the source that was matched.
	ID string `json:"id"`
	// Name is the name of the identified person.
	Name string `json:"name"`
	// Matched is whether the face was recognized or not.
	Matched bool `json:"matched"`
	// Faceprint is the Facebox Faceprint of this face.
	Faceprint string `json:"faceprint"`
	// Rect is where the face appears in the source image.
	Rect Rect `json:"rect"`
}

// FaceprintCompareRequest is the request object for FaceprintCompare calls.
type FaceprintCompareRequest struct {

	// Target is the target Faceprint to which the Faceprints will be compared.
	Target string `json:"target"`
	// Faceprints is a list of Faceprints that will be compared to Target.
	Faceprints []string `json:"faceprints"`
}

// FaceprintCompareResponse is the response object for FaceprintCompare calls.
type FaceprintCompareResponse struct {

	// Confidences is a list of confidence values.
	// The order matches the order of FaceprintCompareRequest.Faceprints.
	Confidences []float64 `json:"confidences"`
	// Error is an error message if one occurred.
	Error string `json:"error"`
}

// FaceprintFace is a face.
type FaceprintFace struct {

	// Matched is whether the face was recognized or not.
	Matched bool `json:"matched"`
	// Confidence is a numerical value of how confident the AI
	// is that this is a match.
	Confidence float64 `json:"confidence"`
	// ID is the identifier of the source that matched.
	ID string `json:"id"`
	// Name is the name of the person recognized.
	Name string `json:"name"`
}

// GetStateRequest is the request object for GetState calls.
type GetStateRequest struct {
}

// PutStateRequest is the request object for PutState calls.
type PutStateRequest struct {

	// StateFile is the Facebox state file to set.
	StateFile remototypes.File `json:"state_file"`
}

// SetStateFile sets the file for the StateFile field.
func (s *PutStateRequest) SetStateFile(ctx context.Context, filename string, r io.Reader) context.Context {
	files, ok := ctx.Value(contextKeyFiles).(map[string]file)
	if !ok {
		files = make(map[string]file)
	}
	fieldname := "files[" + strconv.Itoa(len(files)) + "]"
	files[fieldname] = file{r: r, filename: filename}
	ctx = context.WithValue(ctx, contextKeyFiles, files)
	s.StateFile = remototypes.File{
		Fieldname: fieldname,
		Filename:  filename,
	}
	return ctx
}

// PutStateResponse is the response object for PutState calls.
type PutStateResponse struct {

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

// Rect is a bounding box describing a rectangle of an image.
type Rect struct {

	// Top is the starting Y coordinate.
	Top int `json:"top"`
	// Left is the starting X coordinate.
	Left int `json:"left"`
	// Width is the width.
	Width int `json:"width"`
	// Height is the height.
	Height int `json:"height"`
}

// RemoveIDRequest is the request object for RemoveID calls.
type RemoveIDRequest struct {

	// ID is the identifier of the source to remove.
	ID string `json:"id"`
}

// RemoveIDResponse is the response object for RemoveID calls.
type RemoveIDResponse struct {

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

// RenameIDRequest is the request object for RenameID calls.
type RenameIDRequest struct {

	// ID is the identifier of the source to rename.
	ID string `json:"id"`
	// Name is the new name to assign to the item matching ID.
	Name string `json:"name"`
}

// RenameIDResponse is the response object for RenameID calls.
type RenameIDResponse struct {

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

// RenameRequest is the request object for Rename calls.
type RenameRequest struct {

	// From is the original name.
	From string `json:"from"`
	// To is the new name.
	To string `json:"to"`
}

// RenameResponse is the response object for Rename calls.
type RenameResponse struct {

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

// SimilarFace is a detected face with similar matching faces.
type SimilarFace struct {

	// Rect is where the face appears in the image.
	Rect Rect `json:"rect"`
	// SimilarFaces is a list of similar faces.
	SimilarFaces []Face `json:"similar_faces"`
}

// SimilarFileRequest is the request object for SimilarFile calls.
type SimilarFileRequest struct {
	File remototypes.File `json:"file"`
}

// SetFile sets the file for the File field.
func (s *SimilarFileRequest) SetFile(ctx context.Context, filename string, r io.Reader) context.Context {
	files, ok := ctx.Value(contextKeyFiles).(map[string]file)
	if !ok {
		files = make(map[string]file)
	}
	fieldname := "files[" + strconv.Itoa(len(files)) + "]"
	files[fieldname] = file{r: r, filename: filename}
	ctx = context.WithValue(ctx, contextKeyFiles, files)
	s.File = remototypes.File{
		Fieldname: fieldname,
		Filename:  filename,
	}
	return ctx
}

// SimilarFileResponse is the response object for SimilarFile calls.
type SimilarFileResponse struct {
	Faces []SimilarFace `json:"faces"`
	// Error is an error message if one occurred.
	Error string `json:"error"`
}

// SimilarIDRequest is the request object for SimilarID calls.
type SimilarIDRequest struct {

	// ID is the identifier of the source to look for similar faces of.
	ID string `json:"id"`
}

// SimilarIDResponse is the response object for SimilarID calls.
type SimilarIDResponse struct {

	// Faces is a list of similar faces.
	Faces []SimilarFace `json:"faces"`
	// Error is an error message if one occurred.
	Error string `json:"error"`
}

// SimilarURLRequest is the request object for SimilarURL calls.
type SimilarURLRequest struct {
	URL string `json:"url"`
}

// SimilarURLResponse is the response object for SimilarURL calls.
type SimilarURLResponse struct {
	Faces []SimilarFace `json:"faces"`
	// Error is an error message if one occurred.
	Error string `json:"error"`
}

// TeachFaceprintRequest is the request object for TeachFaceprint calls.
type TeachFaceprintRequest struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Faceprint string `json:"faceprint"`
}

// TeachFaceprintResponse is the response object for TeachFaceprint calls.
type TeachFaceprintResponse struct {

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

// TeachFileRequest is the request object for TeachFile calls.
type TeachFileRequest struct {

	// ID is an identifier describing the source, for example the filename.
	ID string `json:"id"`
	// Name is the name of the person in the image.
	Name string `json:"name"`
	// File is the image containing the face to teach.
	File remototypes.File `json:"file"`
}

// SetFile sets the file for the File field.
func (s *TeachFileRequest) SetFile(ctx context.Context, filename string, r io.Reader) context.Context {
	files, ok := ctx.Value(contextKeyFiles).(map[string]file)
	if !ok {
		files = make(map[string]file)
	}
	fieldname := "files[" + strconv.Itoa(len(files)) + "]"
	files[fieldname] = file{r: r, filename: filename}
	ctx = context.WithValue(ctx, contextKeyFiles, files)
	s.File = remototypes.File{
		Fieldname: fieldname,
		Filename:  filename,
	}
	return ctx
}

// TeachFileResponse is the response object for TeachFile calls.
type TeachFileResponse struct {

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

// TeachURLRequest is the request object for TeachURL calls.
type TeachURLRequest struct {

	// ID is an identifier describing the source, for example the filename.
	ID string `json:"id"`
	// Name is the name of the person in the image.
	Name string `json:"name"`
	// URL is the address of the image.
	URL string `json:"url"`
}

// TeachURLResponse is the response object for TeachURL calls.
type TeachURLResponse struct {

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

// contextKey is a local context key type.
// see https://medium.com/@matryer/context-keys-in-go-5312346a868d
type contextKey string

func (c contextKey) String() string {
	return "remoto context key: " + string(c)
}

// contextKeyFiles is the context key for the request files.
var contextKeyFiles = contextKey("files")

// file holds info about a file in the context, including
// the io.Reader where the contents will be read from.
type file struct {
	r        io.Reader
	filename string
}

// this is here so we don't get a compiler complaints.
func init() {
	var _ = remototypes.File{}
	var _ = strconv.Itoa(0)
	var _ = ioutil.Discard
}
