// Code generated by Remoto; DO NOT EDIT.

package suggestionbox

import (
	"context"
	"encoding/json"
	"io"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"strconv"

	"github.com/machinebox/remoto/remototypes"
	"github.com/oxtoacart/bpool"
	"github.com/pkg/errors"
)

// SuggestionboxClient accesses remote Suggestionbox services.
type SuggestionboxClient struct {
	// endpoint is the HTTP endpoint of the remote server.
	endpoint string
	// httpclient is the http.Client to use to make requests.
	httpclient *http.Client
	// bufs is a buffer pool
	bufs *bpool.BufferPool
}

// NewSuggestionboxClient makes a new SuggestionboxClient that will
// use the specified http.Client to make requests.
func NewSuggestionboxClient(endpoint string, client *http.Client) *SuggestionboxClient {
	return &SuggestionboxClient{
		endpoint:   endpoint,
		httpclient: client,
		bufs:       bpool.NewBufferPool(48),
	}
}

func (c *SuggestionboxClient) CreateModel(ctx context.Context, request *CreateModelRequest) (*CreateModelResponse, error) {
	resp, err := c.CreateModelMulti(ctx, []*CreateModelRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("SuggestionboxClient.CreateModel: no response")
	}
	return resp[0], nil
}

func (c *SuggestionboxClient) CreateModelMulti(ctx context.Context, requests []*CreateModelRequest) ([]*CreateModelResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.CreateModel: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.CreateModel: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.CreateModel: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.CreateModel: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Suggestionbox.CreateModel", buf)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.CreateModel: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.CreateModel: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("SuggestionboxClient.CreateModel: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.CreateModel: read response body")
	}
	var resps []*CreateModelResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.CreateModel: decode response body")
	}
	return resps, nil
}

func (c *SuggestionboxClient) DeleteModel(ctx context.Context, request *DeleteModelRequest) (*DeleteModelResponse, error) {
	resp, err := c.DeleteModelMulti(ctx, []*DeleteModelRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("SuggestionboxClient.DeleteModel: no response")
	}
	return resp[0], nil
}

func (c *SuggestionboxClient) DeleteModelMulti(ctx context.Context, requests []*DeleteModelRequest) ([]*DeleteModelResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.DeleteModel: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.DeleteModel: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.DeleteModel: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.DeleteModel: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Suggestionbox.DeleteModel", buf)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.DeleteModel: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.DeleteModel: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("SuggestionboxClient.DeleteModel: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.DeleteModel: read response body")
	}
	var resps []*DeleteModelResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.DeleteModel: decode response body")
	}
	return resps, nil
}

func (c *SuggestionboxClient) GetState(ctx context.Context, request *GetStateRequest) (io.ReadCloser, error) {
	b, err := json.Marshal([]interface{}{request})
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.GetState: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.GetState: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.GetState: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.GetState: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Suggestionbox.GetState", buf)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.GetState: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.GetState: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("SuggestionboxClient.GetState: remote service returned %s", resp.Status)
	}
	return resp.Body, nil
}

func (c *SuggestionboxClient) ListModels(ctx context.Context, request *ListModelsRequest) (*ListModelsResponse, error) {
	resp, err := c.ListModelsMulti(ctx, []*ListModelsRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("SuggestionboxClient.ListModels: no response")
	}
	return resp[0], nil
}

func (c *SuggestionboxClient) ListModelsMulti(ctx context.Context, requests []*ListModelsRequest) ([]*ListModelsResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.ListModels: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.ListModels: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.ListModels: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.ListModels: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Suggestionbox.ListModels", buf)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.ListModels: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.ListModels: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("SuggestionboxClient.ListModels: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.ListModels: read response body")
	}
	var resps []*ListModelsResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.ListModels: decode response body")
	}
	return resps, nil
}

func (c *SuggestionboxClient) Predict(ctx context.Context, request *PredictRequest) (*PredictResponse, error) {
	resp, err := c.PredictMulti(ctx, []*PredictRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("SuggestionboxClient.Predict: no response")
	}
	return resp[0], nil
}

func (c *SuggestionboxClient) PredictMulti(ctx context.Context, requests []*PredictRequest) ([]*PredictResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Predict: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.Predict: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.Predict: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Predict: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Suggestionbox.Predict", buf)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Predict: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Predict: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("SuggestionboxClient.Predict: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Predict: read response body")
	}
	var resps []*PredictResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Predict: decode response body")
	}
	return resps, nil
}

func (c *SuggestionboxClient) PutState(ctx context.Context, request *PutStateRequest) (*PutStateResponse, error) {
	resp, err := c.PutStateMulti(ctx, []*PutStateRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("SuggestionboxClient.PutState: no response")
	}
	return resp[0], nil
}

func (c *SuggestionboxClient) PutStateMulti(ctx context.Context, requests []*PutStateRequest) ([]*PutStateResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.PutState: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.PutState: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.PutState: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.PutState: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Suggestionbox.PutState", buf)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.PutState: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.PutState: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("SuggestionboxClient.PutState: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.PutState: read response body")
	}
	var resps []*PutStateResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.PutState: decode response body")
	}
	return resps, nil
}

func (c *SuggestionboxClient) Reward(ctx context.Context, request *RewardRequest) (*RewardResponse, error) {
	resp, err := c.RewardMulti(ctx, []*RewardRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("SuggestionboxClient.Reward: no response")
	}
	return resp[0], nil
}

func (c *SuggestionboxClient) RewardMulti(ctx context.Context, requests []*RewardRequest) ([]*RewardResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Reward: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.Reward: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "SuggestionboxClient.Reward: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Reward: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Suggestionbox.Reward", buf)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Reward: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Reward: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("SuggestionboxClient.Reward: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Reward: read response body")
	}
	var resps []*RewardResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "SuggestionboxClient.Reward: decode response body")
	}
	return resps, nil
}

type Choice struct {
	ID       string    `json:"id"`
	Features []Feature `json:"features"`
}

type CreateModelRequest struct {
	Model Model `json:"model"`
}

type CreateModelResponse struct {

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type DeleteModelRequest struct {
	ModelID string `json:"model_id"`
}

type DeleteModelResponse struct {

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type Feature struct {
	Key   string           `json:"key"`
	Type  string           `json:"type"`
	Value string           `json:"value"`
	File  remototypes.File `json:"file"`
}

// SetFile sets the file for the File field.
func (s *Feature) SetFile(ctx context.Context, filename string, r io.Reader) context.Context {
	files, ok := ctx.Value(contextKeyFiles).(map[string]file)
	if !ok {
		files = make(map[string]file)
	}
	fieldname := "files[" + strconv.Itoa(len(files)) + "]"
	files[fieldname] = file{r: r, filename: filename}
	ctx = context.WithValue(ctx, contextKeyFiles, files)
	s.File = remototypes.File{
		Fieldname: fieldname,
		Filename:  filename,
	}
	return ctx
}

// OpenFile opens the file from the response.
func (s *Feature) OpenFile(ctx context.Context) (io.Reader, error) {
	return nil, nil
}

type GetStateRequest struct {
}

type ListModelsRequest struct {
}

type ListModelsResponse struct {
	Models []Model `json:"models"`
	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type Model struct {
	ID      string       `json:"id"`
	Name    string       `json:"name"`
	Options ModelOptions `json:"options"`
	Choices []Choice     `json:"choices"`
}

type ModelOptions struct {
	RewardExpirationSeconds int     `json:"reward_expiration_seconds"`
	Ngrams                  int     `json:"ngrams"`
	Skipgrams               int     `json:"skipgrams"`
	Mode                    string  `json:"mode"`
	Epsilon                 float64 `json:"epsilon"`
	Cover                   float64 `json:"cover"`
}

type PredictRequest struct {
	ModelID string    `json:"model_id"`
	Limit   int       `json:"limit"`
	Inputs  []Feature `json:"inputs"`
}

type PredictResponse struct {
	Choices []PredictedChoice `json:"choices"`
	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type PredictedChoice struct {
	ID       string    `json:"id"`
	Features []Feature `json:"features"`
	RewardID string    `json:"reward_id"`
}

type PutStateRequest struct {
	StateFile remototypes.File `json:"state_file"`
}

// SetStateFile sets the file for the StateFile field.
func (s *PutStateRequest) SetStateFile(ctx context.Context, filename string, r io.Reader) context.Context {
	files, ok := ctx.Value(contextKeyFiles).(map[string]file)
	if !ok {
		files = make(map[string]file)
	}
	fieldname := "files[" + strconv.Itoa(len(files)) + "]"
	files[fieldname] = file{r: r, filename: filename}
	ctx = context.WithValue(ctx, contextKeyFiles, files)
	s.StateFile = remototypes.File{
		Fieldname: fieldname,
		Filename:  filename,
	}
	return ctx
}

type PutStateResponse struct {

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type RewardRequest struct {
	ModelID  string `json:"model_id"`
	RewardID string `json:"reward_id"`
	Value    int    `json:"value"`
}

type RewardResponse struct {

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

// contextKey is a local context key type.
// see https://medium.com/@matryer/context-keys-in-go-5312346a868d
type contextKey string

func (c contextKey) String() string {
	return "remoto context key: " + string(c)
}

// contextKeyFiles is the context key for the request files.
var contextKeyFiles = contextKey("files")

// file holds info about a file in the context, including
// the io.Reader where the contents will be read from.
type file struct {
	r        io.Reader
	filename string
}

// this is here so we don't get a compiler complaints.
func init() {
	var _ = remototypes.File{}
	var _ = strconv.Itoa(0)
	var _ = ioutil.Discard
}
