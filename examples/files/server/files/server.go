// Code generated by Remoto; DO NOT EDIT.

// Package files contains the HTTP server for files services.
package files

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"os"
	"strconv"

	"github.com/machinebox/remoto/go/remotohttp"
	"github.com/machinebox/remoto/go/remotohttp/remototypes"
	"github.com/pkg/errors"
)

// Images provides image services.
type Images interface {
	Flip(context.Context, *FlipRequest) (*remototypes.FileResponse, error)
}

// Run is the simplest way to run the services.
func Run(addr string,
	images Images,
) error {
	server := New(
		images,
	)
	if err := server.Describe(os.Stdout); err != nil {
		return errors.Wrap(err, "describe service")
	}
	if err := http.ListenAndServe(addr, server); err != nil {
		return err
	}
	return nil
}

// New makes a new remotohttp.Server with the specified services
// registered.
func New(
	images Images,
) *remotohttp.Server {
	server := &remotohttp.Server{
		OnErr: func(w http.ResponseWriter, r *http.Request, err error) {
			fmt.Fprintf(os.Stderr, "%s %s: %s\n", r.Method, r.URL.Path, err.Error())
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
		NotFound: http.NotFoundHandler(),
	}

	RegisterImagesServer(server, images)
	return server
}

// RegisterImagesServer registers a Images with a remotohttp.Server.
func RegisterImagesServer(server *remotohttp.Server, service Images) {
	srv := &httpImagesServer{
		service: service,
		server:  server,
	}
	server.Register("/remoto/Images.Flip", http.HandlerFunc(srv.handleFlip))

}

// FlipRequest is the request for Images.Flip.
type FlipRequest struct {
	Image remototypes.File `json:"image"`
}

// httpImagesServer is an internal type that provides an
// HTTP wrapper around Images.
type httpImagesServer struct {
	// service is the Images being exposed by this
	// server.
	service Images
	// server is the remotohttp.Server that this server is
	// registered with.
	server *remotohttp.Server
}

// handleFlip is an http.Handler wrapper for Images.Flip.
func (srv *httpImagesServer) handleFlip(w http.ResponseWriter, r *http.Request) {
	var reqs []*FlipRequest
	if err := remotohttp.Decode(r, &reqs); err != nil {
		srv.server.OnErr(w, r, err)
		return
	}

	// single file response

	if len(reqs) != 1 {
		if err := remotohttp.EncodeErr(w, r, errors.New("only single requests supported for file response endpoints")); err != nil {
			srv.server.OnErr(w, r, err)
			return
		}
		return
	}

	resp, err := srv.service.Flip(r.Context(), reqs[0])
	if err != nil {
		resp.Error = err.Error()
		if err := remotohttp.Encode(w, r, http.StatusOK, []interface{}{resp}); err != nil {
			srv.server.OnErr(w, r, err)
			return
		}
	}
	if resp.ContentType == "" {
		resp.ContentType = "application/octet-stream"
	}
	w.Header().Set("Content-Type", resp.ContentType)
	w.Header().Set("Content-Disposition", "attachment; filename="+strconv.QuoteToASCII(resp.Filename))
	if resp.ContentLength > 0 {
		w.Header().Set("Content-Length", strconv.Itoa(resp.ContentLength))
	}
	if _, err := io.Copy(w, resp.Data); err != nil {
		srv.server.OnErr(w, r, err)
		return
	}

}

// this is here so we don't get a compiler complaints.
func init() {
	var _ = remototypes.File{}
	var _ = strconv.Itoa(0)
	var _ = io.EOF
}
