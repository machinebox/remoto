// Code generated by Remoto; DO NOT EDIT.
<%

let serverName = fn(serviceName) {
	return serviceName + "Server"
}

%>

// Package <%= def.PackageName %> contains the HTTP server for <%= def.PackageName %> services.
package <%= def.PackageName %>

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"os"
	"strconv"

	"github.com/machinebox/remoto/go/remotohttp"
	"github.com/machinebox/remoto/go/remotohttp/remototypes"
	"github.com/pkg/errors"
)

<%= for (service) in def.Services { %>
<%= print_comment(service.Comment) %>type <%= service.Name %> interface {
	<%= for (method) in service.Methods { %>
	<%= print_comment(method.Comment) %><%= method.Name %>(context.Context, *<%= method.RequestStructure.Name %>) (*<%= method.ResponseStructure.Name %>, error)
<% } %>
}

// Run is the simplest way to run the services.
func Run(addr string,
<%= for (service) in def.Services { %>	<%= camelize_down(service.Name) %> <%= service.Name %>,
<% } %>) error {
	server := New(
<%= for (service) in def.Services { %>		<%= camelize_down(service.Name) %>,
<% } %>	)
	if err := server.Describe(os.Stdout); err != nil {
		return errors.Wrap(err, "describe service")
	}
	if err := http.ListenAndServe(addr, server); err != nil {
		return err
	}
	return nil
}

// New makes a new remotohttp.Server with the specified services
// registered.
func New(
<%= for (service) in def.Services { %>	<%= camelize_down(service.Name) %> <%= service.Name %>,
<% } %>) *remotohttp.Server {
	server := &remotohttp.Server{
		OnErr: func(w http.ResponseWriter, r *http.Request, err error) {
			fmt.Fprintf(os.Stderr, "%s %s: %s\n", r.Method, r.URL.Path, err.Error())
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
		NotFound: http.NotFoundHandler(),
	}
	<%= for (service) in def.Services { %>
	Register<%= service.Name %>Server(server, <%= camelize_down(service.Name) %>)<% } %>
	return server
}

// Register<%= service.Name %>Server registers a <%= service.Name %> with a remotohttp.Server.
func Register<%= service.Name %>Server(server *remotohttp.Server, service <%= service.Name %>) {
	srv := &http<%= service.Name %>Server{
		service: service,
		server: server,
	}
	<%= for (method) in service.Methods { %>server.Register("/remoto/<%= service.Name %>.<%= method.Name %>", http.HandlerFunc(srv.handle<%= method.Name %>))
	<% } %>
}

<%= for (structure) in unique_structures(def) { %>
<%= print_comment(structure.Comment) %>type <%= structure.Name %> struct {
	<%= for (field) in structure.Fields { %>
	<%= print_comment(field.Comment) %><%= field.Name %> <%= go_type_string(field.Type) %> `json:"<%= camelize_down(field.Name) %>"`
	<% } %>
}

<% } %>

// http<%= service.Name %>Server is an internal type that provides an
// HTTP wrapper around <%= service.Name %>.
type http<%= service.Name %>Server struct {
	// service is the <%= service.Name %> being exposed by this
	// server.
	service <%= service.Name %>
	// server is the remotohttp.Server that this server is
	// registered with.
	server *remotohttp.Server
}

<%= for (method) in service.Methods { %>
// handle<%= method.Name %> is an http.Handler wrapper for <%= service.Name %>.<%= method.Name %>.
func (srv *http<%= service.Name %>Server) handle<%= method.Name %>(w http.ResponseWriter, r *http.Request) {
	var reqs []*<%= method.RequestStructure.Name %>
	if err := remotohttp.Decode(r, &reqs); err != nil {
		srv.server.OnErr(w, r, err)
		return
	}
	<%= if (method.ResponseStructure.Name == "remototypes.FileResponse") { %>
	// single file response

	if len(reqs) != 1 {
		if err := remotohttp.EncodeErr(w, r, errors.New("only single requests supported for file response endpoints")); err != nil {
			srv.server.OnErr(w, r, err)
			return
		}
		return
	}

	resp, err := srv.service.<%= method.Name %>(r.Context(), reqs[0])
	if err != nil {
		resp.Error = err.Error()
		if err := remotohttp.Encode(w, r, http.StatusOK, []interface{}{ resp }); err != nil {
			srv.server.OnErr(w, r, err)
			return
		}
	}
	if resp.ContentType == "" {
		resp.ContentType = "application/octet-stream"
	}
	w.Header().Set("Content-Type", resp.ContentType)
	w.Header().Set("Content-Disposition", "attachment; filename=" + strconv.QuoteToASCII(resp.Filename))
	if resp.ContentLength > 0 {
		w.Header().Set("Content-Length", strconv.Itoa(resp.ContentLength))
	}
	if _, err := io.Copy(w, resp.Data); err != nil {
		srv.server.OnErr(w, r, err)
		return
	}
	<% } else { %>
	resps := make([]<%= method.ResponseStructure.Name %>, len(reqs))
	for i := range reqs {
		resp, err := srv.service.<%= method.Name %>(r.Context(), reqs[i])
		if err != nil {
			resps[i].Error = err.Error()
			continue
		}
		resps[i] = *resp
	}
	if err := remotohttp.Encode(w, r, http.StatusOK, resps); err != nil {
		srv.server.OnErr(w, r, err)
		return
	}
	<% } %>
}<% } %> 

<% } %>

// this is here so we don't get a compiler complaints.
func init() {
	var _ = remototypes.File{}
	var _ = strconv.Itoa(0)
	var _ = io.EOF
}
