<%# 

	This is a plush template
	see https://github.com/gobuffalo/plush

%><%

let serverName = fn(serviceName) {
	return serviceName + "Server"
}

%>// Code generated by Remoto; DO NOT EDIT.

// Package <%= def.PackageName %> contains the HTTP server for <%= def.PackageName %> services.
package <%= def.PackageName %>

import (
	"context"
	"fmt"
	"net/http"
	"os"

	"github.com/machinebox/remoto/go/remotohttp"
	"github.com/machinebox/remoto/remototypes"
	"github.com/pkg/errors"
)

// Run is the simplest way to run the services.
func Run(addr string,
<%= for (service) in def.Services { %>	<%= camelize_down_first(service.Name) %> <%= service.Name %>,
<% } %>) error {
	server := New(
<%= for (service) in def.Services { %>		<%= camelize_down_first(service.Name) %>,
<% } %>	)
	if err := server.Describe(os.Stdout); err != nil {
		return errors.Wrap(err, "describe service")
	}
	if err := http.ListenAndServe(addr, server); err != nil {
		return err
	}
	return nil
}

// New makes a new remotohttp.Server with the specified services
// registered.
func New(
<%= for (service) in def.Services { %>	<%= camelize_down_first(service.Name) %> <%= service.Name %>,
<% } %>) *remotohttp.Server {
	server := &remotohttp.Server{
		OnErr: func(w http.ResponseWriter, r *http.Request, err error) {
			fmt.Fprintf(os.Stderr, "%s %s: %s\n", r.Method, r.URL.Path, err.Error())
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}
	<%= for (service) in def.Services { %>
	Register<%= service.Name %>Server(server, <%= camelize_down_first(service.Name) %>)<% } %>
	return server
}

<%= for (structure) in unique_structures(def) { %>
<%= print_comment(structure.Comment) %>type <%= structure.Name %> struct {
	<%= for (field) in structure.Fields { %>
	<%= print_comment(field.Comment) %><%= field.Name %> <%= go_type_string(field.Type) %> `json:"<%= underscore(field.Name) %>"`
	<% } %>
}

<% } %>

<%= for (service) in def.Services { %>
<%= print_comment(service.Comment) %>type <%= service.Name %> interface {
	<%= for (method) in service.Methods { %><%= print_comment(method.Comment) %>
	<%= method.Name %>(context.Context, *<%= method.RequestType.Name %>) (*<%= method.ResponseType.Name %>, error)
<% } %>
}

// Register<%= service.Name %>Server registers a <%= service.Name %> with a remotohttp.Server.
func Register<%= service.Name %>Server(server *remotohttp.Server, service <%= service.Name %>) {
	srv := &http<%= service.Name %>Server{
		service: service,
		server: server,
	}
	<%= for (method) in service.Methods { %>
	server.Register("/remoto/<%= service.Name %>.<%= method.Name %>", http.HandlerFunc(srv.handle<%= method.Name %>))
	<% } %>
}

// http<%= service.Name %>Server is an internal type that provides an
// HTTP wrapper around <%= service.Name %>.
type http<%= service.Name %>Server struct {
	// service is the <%= service.Name %> being exposed by this
	// server.
	service <%= service.Name %>
	// server is the remotohttp.Server that this server is
	// registered with.
	server *remotohttp.Server
}

<%= for (method) in service.Methods { %>
// handle<%= method.Name %> is an http.Handler wrapper for <%= service.Name %>.<%= method.Name %>.
func (srv *http<%= service.Name %>Server) handle<%= method.Name %>(w http.ResponseWriter, r *http.Request) {
	var reqs []*<%= method.RequestType.Name %>
	if err := remotohttp.Decode(r, &reqs); err != nil {
		srv.server.OnErr(w, r, err)
		return
	}
	resps := make([]<%= method.ResponseType.Name %>, len(reqs))
	for i := range reqs {
		resp, err := srv.service.<%= method.Name %>(r.Context(), reqs[i])
		if err != nil {
			resps[i].Error = err.Error()
			continue
		}
		resps[i] = *resp
	}
	if err := remotohttp.Encode(w, r, http.StatusOK, resps); err != nil {
		srv.server.OnErr(w, r, err)
		return
	}
}<% } %> 

<% } %>

// this is here so we don't get a compiler complaint about 
// importing remototypes but not using it.
var _ = remototypes.File("ignore me")
