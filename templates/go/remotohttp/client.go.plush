<%# 

	This is a plush template
	see https://github.com/gobuffalo/plush

%><%

let serverName = fn(serviceName) {
	return serviceName + "Server"
}

%>// Code generated by Remoto; DO NOT EDIT.

package <%= def.PackageName %>

import (
	"context"
	"encoding/json"
	"io"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"strconv"

	"github.com/machinebox/remoto/remototypes"
	"github.com/oxtoacart/bpool"
	"github.com/pkg/errors"
)

<%= for (service) in def.Services { %>
// <%= service.Name %>Client accesses remote <%= service.Name %> services.
type <%= service.Name %>Client struct {
    // endpoint is the HTTP endpoint of the remote server.
    endpoint string
    // httpclient is the http.Client to use to make requests.
    httpclient *http.Client
	// bufs is a buffer pool
	bufs *bpool.BufferPool
}

// New<%= service.Name %>Client makes a new <%= service.Name %>Client that will
// use the specified http.Client to make requests.
func New<%= service.Name %>Client(endpoint string, client *http.Client) *<%= service.Name %>Client {
    return &<%= service.Name %>Client{
        endpoint: endpoint,
        httpclient: client,
		bufs: bpool.NewBufferPool(48),
    }
}

<%= for (method) in service.Methods { %>
<%= print_comment(method.Comment) %>func (c *<%= service.Name %>Client) <%= method.Name %>(ctx context.Context, request *<%= method.RequestType.Name %>) (*<%= method.ResponseType.Name %>, error) {
	resp, err := c.<%= method.Name %>Multi(ctx, []*<%= method.RequestType.Name %>{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("<%= service.Name %>Client.<%= method.Name %>: no response")
	}
	return resp[0], nil
}

func (c *<%= service.Name %>Client) <%= method.Name %>Multi(ctx context.Context, requests []*<%= method.RequestType.Name %>) ([]*<%= method.ResponseType.Name %>, error) {
	b, err := json.Marshal(requests)
    if err != nil {
        return nil, errors.Wrap(err, "<%= service.Name %>Client.<%= method.Name %>: encode request")
    }
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "<%= service.Name %>Client.<%= method.Name %>: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "<%= service.Name %>Client.<%= method.Name %>: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "<%= service.Name %>Client.<%= method.Name %>: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint + "/remoto/<%= service.Name %>.<%= method.Name %>", buf)
	if err != nil {
		return nil, errors.Wrap(err, "<%= service.Name %>Client.<%= method.Name %>: new request")
	}
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "<%= service.Name %>Client.<%= method.Name %>: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("<%= service.Name %>Client.<%= method.Name %>: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "<%= service.Name %>Client.<%= method.Name %>: read response body")
	}
	var resps []*<%= method.ResponseType.Name %>
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "<%= service.Name %>Client.<%= method.Name %>: decode response body")
	}
	return resps, nil
}
<% } %>
<% } %>

<%= for (structure) in unique_structures(def) { %><%= print_comment(structure.Comment) %>
type <%= structure.Name %> struct {
    <%= for (field) in structure.Fields { %>
	<%= print_comment(field.Comment) %><%= field.Name %> <%= go_type_string(field.Type) %> `json:"<%= underscore(field.Name) %>"`<% } %>
}

<%= for (field) in structure.Fields { %>
<%= if (field.Type.Name == "remototypes.File") { %>
// Set<%= field.Name %> puts a file into the context ready for the request.
func (s *<%= structure.Name %>) Set<%= field.Name %>(ctx context.Context, filename string, r io.Reader) context.Context {
	files, ok := ctx.Value(contextKeyFiles).(map[string]file)
	if !ok {
		files = make(map[string]file)
	}
	fieldname := "files["+ strconv.Itoa(len(files)) + "]"
	files[fieldname] = file{r: r, filename: filename}
	ctx = context.WithValue(ctx, contextKeyFiles, files)
	s.<%= field.Name %> = remototypes.NewFile(fieldname)
	return ctx
}
<% } %>
<% } %>

<% } %>

type contextKey string

func (c contextKey) String() string {
	return "remoto context key: " + string(c)
}

var contextKeyFiles = contextKey("files")

type file struct {
	r io.Reader
	filename string
}

// this is here so we don't get a compiler complaint about 
// importing remototypes but not using it.
var _ = remototypes.File("ignore me")
