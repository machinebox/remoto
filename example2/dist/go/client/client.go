// Code generated by Remoto; DO NOT EDIT.

package example

import (
	"context"
	"encoding/json"
	"io"
	"io/ioutil"
	"mime/multipart"
	"net/http"

	"github.com/machinebox/remoto/remototypes"
	"github.com/oxtoacart/bpool"
	"github.com/pkg/errors"
)

var _ = remototypes.File("ignore me")

// FaceboxClient accesses remote Facebox services.
type FaceboxClient struct {
	// endpoint is the HTTP endpoint of the remote server.
	endpoint string
	// httpclient is the http.Client to use to make requests.
	httpclient *http.Client
	// bufs is a buffer pool
	bufs *bpool.BufferPool
}

// NewFaceboxClient makes a new FaceboxClient that will
// use the specified http.Client to make requests.
func NewFaceboxClient(endpoint string, client *http.Client) *FaceboxClient {
	return &FaceboxClient{
		endpoint:   endpoint,
		httpclient: client,
		bufs:       bpool.NewBufferPool(48),
	}
}

func (c *FaceboxClient) Check(ctx context.Context, request *CheckRequest) (*CheckResponse, error) {
	resp, err := c.CheckMulti(ctx, []*CheckRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("Facebox.Check: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) CheckMulti(ctx context.Context, requests []*CheckRequest) ([]*CheckResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "Facebox.Check: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))

	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "Facebox.Check: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.Check", buf)
	if err != nil {
		return nil, errors.Wrap(err, "Facebox.Check: new request")
	}
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "Facebox.Check: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("Facebox.Check: remote service returned %d", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "Facebox.Check: read response body")
	}
	var resps []*CheckResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "Facebox.Check: decode response body")
	}
	return resps, nil
}

func (c *FaceboxClient) Teach(ctx context.Context, request *TeachRequest) (*TeachResponse, error) {
	resp, err := c.TeachMulti(ctx, []*TeachRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("Facebox.Teach: no response")
	}
	return resp[0], nil
}

func (c *FaceboxClient) TeachMulti(ctx context.Context, requests []*TeachRequest) ([]*TeachResponse, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "Facebox.Teach: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))

	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "Facebox.Teach: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Facebox.Teach", buf)
	if err != nil {
		return nil, errors.Wrap(err, "Facebox.Teach: new request")
	}
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "Facebox.Teach: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("Facebox.Teach: remote service returned %d", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "Facebox.Teach: read response body")
	}
	var resps []*TeachResponse
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "Facebox.Teach: decode response body")
	}
	return resps, nil
}

type TeachFile struct {
	Image remototypes.File
}

// ImageFile puts a file into the context ready for the request.
func (s *TeachFile) ImageFile(ctx context.Context, filename string, r io.Reader) context.Context {
	ctx = context.WithValue(ctx, contextKey("TeachFile.Image:filename", filename))
	ctx = context.WithValue(ctx, contextKey("TeachFile.Image:r", r))
	return ctx
}

type TeachRequest struct {
	Name string

	TeachFiles []TeachFile
}

type TeachResponse struct {

	// Error is an error message if one occurred.
	Error string
}

type CheckRequest struct {
	Image remototypes.File
}

// ImageFile puts a file into the context ready for the request.
func (s *CheckRequest) ImageFile(ctx context.Context, filename string, r io.Reader) context.Context {
	ctx = context.WithValue(ctx, contextKey("CheckRequest.Image:filename", filename))
	ctx = context.WithValue(ctx, contextKey("CheckRequest.Image:r", r))
	return ctx
}

type Faces struct {
	Name string

	Matched bool
}

type CheckResponse struct {
	Faces []Faces

	// Error is an error message if one occurred.
	Error string
}

type contextKey string

func file(ctx context.Context, name string)
